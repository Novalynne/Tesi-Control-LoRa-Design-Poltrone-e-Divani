{% extends "base.html" %}
{% load crispy_forms_tags %}

{% block title %}Generate Image{% endblock %}
{% block css %}
<style>
  .asteriskField { display: none; }
  label { font-weight: bold; }
  .helptext, .form-text, .text-muted { display: none !important; }

  #editCanvas {
    border: 2px solid #333;
    cursor: crosshair;
  }
</style>
{% endblock %}

{% block content %}
<div class="container">

  <h1 class="mt-4 mb-4 text-center">AI Image Generator</h1>

  <div class="card shadow p-4">
    <form id="imageForm" method="POST" enctype="multipart/form-data">
      {% csrf_token %}

      <!-- Tutti i campi base del form -->
      {{ form.input_image|as_crispy_field }}
      {{ form.prompt|as_crispy_field }}
      {{ form.model_choice|as_crispy_field }}
      {{ form.num_steps|as_crispy_field }}

      <!-- Pulsante per aprire le opzioni avanzate -->
      <button class="btn btn-secondary btn-sm mt-2 mb-3" type="button" data-bs-toggle="collapse" data-bs-target="#advancedFields">
        Advanced Options ‚öôÔ∏è
      </button>

      <!-- Campi avanzati nascosti -->
      <div class="collapse" id="advancedFields">
        {{ form.negative_prompt|as_crispy_field }}
        {{ form.lora_weight|as_crispy_field }}
        {{ form.guidance_scale|as_crispy_field }}
        {{ form.conditioning_scale|as_crispy_field }}
      </div>

      <!-- Campo nascosto per salvare il canvas modificato -->
      <input type="hidden" id="canvasEdited" name="canvasEdited">

      <div class="text-center mt-3">
        <button class="btn btn-primary btn-lg" type="submit">
          Generate Image
        </button>
      </div>
    </form>
  </div>


  <!-- Preview section -->
  <div class="mt-4 text-center">
    <h3>Preview Canny / HED</h3>
    <div class="row mt-4 justify-content-center align-items-center text-center">
      <div class="col-md-6 justify-content-center align-items-center text-center">
        <div class="text-center justify-content-center align-items-center">
          <img id="originalPreview" src="" class="img-fluid border" style="max-height: 300px; display:none;">
          <p class="text-muted">Original Image</p>
        </div>
      </div>

      <div class="col-md-6 justify-content-center align-items-center text-center">
        <div class="text-center justify-content-center align-items-center">
          <img id="combinedPreview" src="" class="img-fluid border" style="max-height: 300px; display:none;">
          <p class="text-muted">Canny / HED</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Canvas editor -->
  <div id="editorSection" class="mt-5 text-center" style="display:none;">
    <h3>Modify your Canny/Hed Guide Image</h3>

    <canvas id="editCanvas"></canvas>

    <div class="mt-3">
      <button type="button" id="drawModeBtn" class="btn btn-success btn-sm">‚úèÔ∏è Draw</button>
      <button type="button" id="eraseModeBtn" class="btn btn-danger btn-sm">üßπ Erase</button>

      <label class="ms-3 fw-bold">Brush Dimension:</label>
      <input id="brushSize" type="range" min="2" max="40" value="5">
    </div>
  </div>

  <div id="previewContainer" class="text-center" style="margin-top:20px;">
    <!-- Loading Spinner -->
    <div id="loadingSpinner" class="text-center" style="display:none; margin-top:20px;">
      <div class="spinner-border text-primary" role="status" style="width: 4rem; height: 4rem;">
      </div>
      <p class="mt-2">Generating image...</p>
    </div>

    <!-- Risultato con AJAX quindi senza ricaricare la pagina  -->
    <div id="resultImageContainer" class="text-center mt-4"></div>

    <!-- Risultato senza AJAX quindi con ricaricamento della pagina  -->
    <div id="staticResultContainer" class="text-center mt-4">
      {% if generated_image_base64 %}
      <h3>Generated Image:</h3>
      <img src="data:image/png;base64,{{ generated_image_base64 }}" class="img-fluid border" style="max-height: 500px;"/>
      {% endif %}
      {% if error_message %}
      <p style="color:red">{{ error_message }}</p>
      {% endif %}
    </div>
  </div>

</div>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    const MAX_WIDTH = 1024;
    const MAX_HEIGHT = 1024;

    const imageInput = document.getElementById("id_input_image");
    const editorSection = document.getElementById("editorSection");
    const canvas = document.getElementById("editCanvas");
    const ctx = canvas.getContext("2d");
    const canvasHiddenInput = document.getElementById("canvasEdited");
    const form = document.getElementById("imageForm");

    let drawing = false;
    let mode = "draw";
    let brushSize = 5;

    const brushInput = document.getElementById("brushSize");
    const drawModeBtn = document.getElementById("drawModeBtn");
    const eraseModeBtn = document.getElementById("eraseModeBtn");

    brushInput.addEventListener("input", () => brushSize = parseInt(brushInput.value));
    drawModeBtn.addEventListener("click", () => mode = "draw");
    eraseModeBtn.addEventListener("click", () => mode = "erase");

    // --- CARICAMENTO E PREVIEW ---
    if (imageInput) {
      imageInput.addEventListener("change", function (event) {
        const file = event.target.files[0];
        if (!file) return;

        // Mostra anteprima originale
        const original = document.getElementById("originalPreview");
        original.src = URL.createObjectURL(file);
        original.style.display = "block";

        const formData = new FormData();
        formData.append("image", file);

        fetch("{% url 'generate_preview' %}", {
          method: "POST",
          headers: { "X-CSRFToken": "{{ csrf_token }}" },
          body: formData
        })
                .then(response => response.json())
                .then(data => {
                  if (data.status === "ok") {
                    const combinedPreview = document.getElementById("combinedPreview");
                    combinedPreview.src = data.combined;
                    combinedPreview.style.display = "block";

                    combinedPreview.onload = function () {
                      editorSection.style.display = "block";

                      let w = combinedPreview.naturalWidth;
                      let h = combinedPreview.naturalHeight;

                      // Mantieni proporzioni senza superare il massimo
                      if (w > MAX_WIDTH || h > MAX_HEIGHT) {
                        const ratio = Math.min(MAX_WIDTH / w, MAX_HEIGHT / h);
                        w = Math.round(w * ratio);
                        h = Math.round(h * ratio);
                      }

                      canvas.width = w;
                      canvas.height = h;
                      canvas.style.width = w + "px";
                      canvas.style.height = h + "px";

                      ctx.clearRect(0, 0, w, h);
                      ctx.drawImage(combinedPreview, 0, 0, w, h);
                    };
                  }
                });
      });
    }

    // --- SISTEMA DI DISEGNO ---
    function drawPoint(x, y) {
      ctx.beginPath();
      ctx.arc(x, y, brushSize, 0, Math.PI * 2);
      if (mode === "draw") {
        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = "white";
      } else {
        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = "black";
      }
      ctx.fill();
    }

    canvas.addEventListener("mousedown", () => drawing = true);
    canvas.addEventListener("mouseup", () => { drawing = false; ctx.beginPath(); });
    canvas.addEventListener("mouseout", () => drawing = false);
    canvas.addEventListener("mousemove", (e) => {
      if (!drawing) return;
      const rect = canvas.getBoundingClientRect();
      drawPoint(e.clientX - rect.left, e.clientY - rect.top);
    });

    canvas.addEventListener("touchstart", () => drawing = true);
    canvas.addEventListener("touchend", () => { drawing = false; ctx.beginPath(); });
    canvas.addEventListener("touchcancel", () => drawing = false);
    canvas.addEventListener("touchmove", (e) => {
      if (!drawing) return;
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      drawPoint(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top);
    });

    // --- Salva il canvas modificato prima dell'invio ---
    form.addEventListener("submit", function() {
      canvasHiddenInput.value = canvas.toDataURL("image/png");
    });

  });
</script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    const form = document.getElementById("imageForm");
    const spinner = document.getElementById("loadingSpinner");
    const resultContainer = document.getElementById("resultImageContainer");
    const canvasHiddenInput = document.getElementById("canvasEdited");

    form.addEventListener("submit", async function(e) {
      e.preventDefault();

      // Salva canvas in base64
      canvasHiddenInput.value = document.getElementById("editCanvas").toDataURL("image/png");

      const formData = new FormData(form);

      spinner.style.display = "block";
      resultContainer.innerHTML = "";

      // POST AJAX
      const response = await fetch(form.action || window.location.href, {
        method: "POST",
        body: formData,
        headers: { "X-Requested-With": "XMLHttpRequest" }
      });
      const data = await response.json();

      if (data.status !== "ok") {
        resultContainer.innerHTML = `<p class="text-danger">Form Error</p>`;
        spinner.style.display = "none";
        return;
      }

      const taskId = data.task_id;

      // Polling ogni 2 secondi
      const interval = setInterval(async () => {
        const statusResp = await fetch("{% url 'check_task' 'TASKID_PLACEHOLDER' %}".replace('TASKID_PLACEHOLDER', taskId));
        const statusData = await statusResp.json();

        if (statusData.status === "success" && statusData.image_base64) {
          clearInterval(interval);
          resultContainer.innerHTML = `
                    <h3>Generated Image:</h3>
                    <img src="data:image/png;base64,${statusData.image_base64}" class="img-fluid border" style="max-height:500px;">
                `;
          spinner.style.display = "none";
        } else if (statusData.status === "error") {
          clearInterval(interval);
          resultContainer.innerHTML = `<p class="text-danger">${statusData.message}</p>`;
          spinner.style.display = "none";
        }
      }, 2000);
    });
  });
</script>

{% endblock %}
